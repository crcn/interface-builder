#!/usr/bin/env node
const path = require("path");
const resolve = require("resolve");
const chokidar = require("chokidar");
const glob = require("glob");
const {Engine} = require("paperclip");

const argv = require("yargs")
.option("compiler", {
  describe: "Language compiler target",
})
.option("watch", {
}).argv;


const compiler = argv.compiler;
const filesGlob = argv._[0];

const compilerModulePath = resolve2(compiler);
if (!compilerModulePath) {
  console.error("Compiler \"%s\" couldn't be found", compiler);
  process.exit();
}
const compileModule = require(compilerModulePath);

if (!compileModule || !compileModule.compile) {
  console.error("Compiler \"%s\" does not export compile function", compiler);
  process.exit();
}

const compile = compileModule.compile;
init(process.cwd(), filesGlob, compile, argv.watch);

function resolve2(module) {
  try {
    return resolve.sync(compiler, { basedir: process.cwd() });
  } catch(e) {
    try {
      return require.resolve(module);
    } catch(e) {
      return null;
    }
  }
}

function init(cwd, filesGlob, compile, shouldWatch) {
  
  const pcEngine = new Engine();

  async function compileFile(relativePath) {
    const fullPath = path.resolve(process.cwd(), relativePath);
    try {
      console.log("Compiling %s", relativePath);
      const ast = await pcEngine.parseFile(fullPath);
      const result = compile(ast, fullPath);
      console.log(result);
    } catch(e) {
      console.error(e);
    }
  }
  glob(filesGlob, {
    cwd: cwd
  }, async function(err, filePaths) {
    await Promise.all(filePaths.map(compileFile));
    if (!shouldWatch) {
      pcEngine.dispose();
    }
  });

  if (shouldWatch) {
    watch(cwd, filesGlob, compileFile);
  }
}


function watch(cwd, filesGlob, compileFile) {

  const watcher = chokidar.watch(filesGlob, {
    cwd: cwd
  });

  watcher  
    .on('change', compileFile);
}